---
title: "Delimited Data"
webr:
  packages: ['data.tree', 'here']
---

```{r, include = FALSE}
knitr::opts_chunk$set(message = TRUE)
```

```{webr-r}
#| autorun: true
#| context: setup

dir.create("code")
dir.create("data")
dir.create("output")
dir.create("figures")

download.file("https://openstatprog.com/raw-data/boys.dat", "data/boys.dat")
download.file("https://openstatprog.com/raw-data/boys.RData", "data/boys.RData")
download.file("https://openstatprog.com/raw-data/boys_eu.csv", "data/boys_eu.csv")

download.file("https://openstatprog.com/raw-data/diabetes.txt", "data/diabetes.txt")
download.file("https://openstatprog.com/raw-data/diabetes.rds", "data/diabetes.rds")

download.file("https://openstatprog.com/raw-data/diabetes.txt", "data/iris.txt")
download.file("https://openstatprog.com/raw-data/diabetes.txt", "data/iris.csv")

download.file("https://openstatprog.com/raw-data/titanic.rds", "data/titanic.rds")
download.file("https://openstatprog.com/raw-data/utmb_2017.csv", "data/utmb_2017.csv")
download.file("https://openstatprog.com/raw-data/mtcars.sav", "data/mtcars.sav")
download.file("https://openstatprog.com/raw-data/starwars.sav", "data/starwars.sav")
download.file("https://openstatprog.com/raw-data/example_data.xlsx", "data/example_data.xlsx")

files    <- list.files("./", recursive = TRUE, include.dirs = TRUE, full.names = TRUE)
dir_tree <- data.tree::as.Node(data.frame(pathString = files))
```

Delimited text files are the simplest type of file that you're likely to encounter when loading datasets into R. The
files represent data as plain text where the data values are separated by a specific
delimiter character: comma, tab, space.

While base R provides functions for reading these kinds of files (e.g., `read.table()`, `read.csv()`), the
[**readr**][readr] package from the [**tidyverse**][tidyverse] provides a superior alternative. Relative to their Base R
counterparts, the data-ingest functions in **readr** are faster, easier to configure, and more transparent in how they
parse data.

## Space-Delimited

We'll first consider *space-delimited* files wherein the data values are separated by a single white space character. We
can use the `readr::read_delim()` function to load space-delimited files. When calling `read_delim()` we have two
options for specifying the delimiter:

1. Let the function detect the delimiter automatically (the default)
1. Specify the delimiter via the `delim` argument

```{r}
library(readr)

# Read the `boys.dat` file using default arguments and store the ingested values
# in a data frame called 'boys'
boys <- read_delim("data/boys.dat")
```

When we using `read_delim()` read a file, the function prints an informative message telling us about the delimiter and
the data types that it detected/used. We should check this message to make sure the auto-detection worked correctly.

```{r}
# Check the result
head(boys)
```

Notice that `read_delim()` returns a *tibble* and not an ordinary data frame. Tibbles are just slightly fancier flavor
of data frame used by tidyverse packages. For our purposes, we can treat tibbles and data frames as equivalent objects.

```{r}
# Read the `boys.dat` file with the delimiter specifically defined
boys <- read_delim("data/boys.dat", delim = " ")

# Check the result
head(boys)
```

### Good Path Habits

In the example above, we explicitly wrote out the path to the data file we wanted to read (i.e., `"data/boys.dat"`).
That approach will work, but we can make our lives a lot easier by taking a few steps to improve the portability of our
code. In the following code chunk, we make two important changes:

1. Create a variable called `dataDir` that contains the relative file path from the root directory of our project to the
   data folder.
1. Use the `here()` function from the [**here**][here_package] package to resolve the file path.

```{r, message = FALSE}
library(here)
```

```{r}
dataDir <- "data"

boys <- read_delim(here("data", "boys.dat"))
head(boys)
```

## Tab-Delimited

In a *tab-delimited* file the data values are separated by tab characters (`\t`). In the following code chunk, we load a
file named `diabetes.txt`.

```{r}
# Let the function auto-detect the delimiter
diabetes <- read_delim(here(dataDir, "diabetes.txt"))
head(diabetes)

# Manually explicate the delimiter
diabetes <- read_delim(here(dataDir, "diabetes.txt"), delim = "\t")
head(diabetes)
```

Alternatively, `readr` provides a dedicated function for reading tab-delimited files: `read_tsv()`. This function is
just a wrapper around `read_delim()` with the delimiter preset to the tab character.

```{r}
diabetes <- read_tsv(here(dataDir, "diabetes.txt"))
head(diabetes)
```

::: practice

Use `readr::read_delim()` to load the data stored in the tab-delimited file "./data/iris.txt".

:::: {.panel-tabset}

## {{< var tab_title.editor >}}

```{webr-r}
```

## {{< var tab_title.dir >}}

The following dendrogram illustrates the structure of the working directory for this *webr* session.

```{webr-r}
#| autorun: true
#| context: output

print(dir_tree)
```

## {{< var tab_title.solution >}}

```{r}
iris <- read_delim(here::here("data", "iris.txt"), delim = "\t")
head(iris)
```

::::

:::

## Comma-Separated Values

The *comma-separated values* (CSV) format is one of the most popular delimited file types for storing tabular data. As
the name implies, the data values are separated by commas. We can use the `readr::read_delim()` function with `delim =
","`, but it's more convenient to use the `readr::read_csv()` wrapper function.

```{r}
utmb <- read_delim(here(dataDir, "utmb_2017.csv"), delim = ",")
head(utmb)

utmb <- read_csv(here(dataDir, "utmb_2017.csv"))
head(utmb)
```
### Trouble with Locales

The CSV format was developed in the United States where the period/full-stop character is used as the decimal separator.
In countries that use the comma character to denote decimals (e.g., most European countries), it doesn't make much sense
to separate data fields with commas. In these countries, CSV files use semicolons as the delimiter (though the file type
is still called *comma*-separated, unfortunately).

```{r}
boys <- read_csv(here(dataDir, "boys_eu.csv"))

head(boys) # Oops...that doesn't look right
```

To read these type of EU-formatted CSV files, we can use the `read_csv2()` function.

```{r}
boys <- read_csv2(here(dataDir, "boys_eu.csv"))
head(boys)
```

## Formatting Options

Some files contain known formatting issues that we'd like to correct as quickly as possible. The **readr** data-ingest
functions contain many options that we can use to apply various formatting corrections when reading the data file.

### Missing Values

In many datasets, missing values are represented by placeholder codes, such as `-999`. We can instruct `read_delim()` to
interpret such codes as `NA` by supply a vector of missing data codes for the `na` argument:

```{r}
boys <- read_delim(here(dataDir, "boys.dat"), na = "-999")
head(boys)
```

Notice how all the "-999" values have been replaced by `NA` (R's native missing data code). R will now correctly
recognize these cells as missing values and treat them appropriately.

### Selecting Columns

Some files contain columns that we really don't care about and would rather just throw out immediately. For example, the
first data column often contains an unnecessary row index. With **readr**, we can use the `col_select` argument to drop
these columns directly when we read the data.

```{r}
# Drop the first column when reading the file
utmb <- read_csv(here(dataDir, "utmb_2017.csv"), col_select = -1)
head(utmb)
```

The `col_select` argument can do much more than we show in the above example. You can use any feature of the
[**tidyselect** selection language][tidyselect] to include or exclude columns.

### Column Data Types

By default, `readr` tries to guess the appropriate data type for each column based on the first 1,000 rows. We can use
the `spec()` function to check how any **readr** data-ingest function parsed each column (i.e., which data types the
function assigned).

```{r}
spec(utmb)
```

While the auto-typing process is often correct, it's not infallible. For more control, we can explicitly define column
types using the `col_types` argument, which accepts a specification created using `cols()` and type constructors such as
`col_character()`, `col_integer()`, and `col_factor()`:

```{r}
utmb <- read_csv(
  file       = here(dataDir, "utmb_2017.csv"),
  col_select = -1,
  col_types  = cols(
    bib         = col_character(),
    category    = col_factor(),
    rank        = col_integer(),
    nationality = col_factor()
  )
)
head(utmb)

# Check the data structure
str(utmb)
```

We can also use a compact string format, where each character represents the type of a column (e.g., `"d"` = double,
`"f"` = factor).

```{r}
boys <- read_csv2(here(dataDir, "boys.csv"), col_types = "dddddffdf")
head(boys)
str(boys)
```

::: practice

Use `readr::read_csv()` to load the data stored in "./data/iris.csv".

- Format the `Species` column as a factor
- Remove the `Petal.Width` column while when reading the file.
- Convert "-88" and "-99" to missing values.

:::: {.panel-tabset}

## {{< var tab_title.editor >}}

```{webr-r}
```

## {{< var tab_title.dir >}}

The following dendrogram illustrates the structure of the working directory for this *webr* session.

```{webr-r}
#| autorun: true
#| context: output

print(dir_tree)
```

## {{< var tab_title.solution >}}

```{r}
iris <- read_csv(here::here("data", "iris.csv"),
                 col_types = cols(Species = col_factor()),
                 col_select = c(-ID, -Petal.Width),
                 na = c("-88", "-99"))
head(iris)
```

::::

:::

## Base R Options

Base R also includes built-in functions for reading delimited files. The Base R analogue of `readr::read_delim()` is
`read.table()`. The `read.table()` function won't attempt to auto-detect the delimiter, so we need to explicitly specify
the delimiter character via the `sep` argument.

```{r}
diabetes2 <- read.table(here(dataDir, "diabetes.txt"),
                        header = TRUE,
                        sep = "\t")
head(diabetes2)
```

For CSV files, the `read.csv()` and `read.csv2()` functions are wrappers around `read.table()` that will read
US-formatted and EU-formatted CSV files.

```{r}
# Standard comma-separated CSV file
utmb2 <- read.csv(here(dataDir, "utmb_2017.csv"))
head(utmb2)

# CSV with semicolons as delimiters
boys2 <- read.csv2(here(dataDir, "boys_eu.csv"))
head(boys2)
```

[readr]: https://readr.tidyverse.org/
[tidyverse]: https://tidyverse.org/
[here_package]: https://here.r-lib.org/
[tidyselect]: https://tidyselect.r-lib.org/reference/language.html
